#Zadatak 2.
>>>Ispiši tekst "Prvi redak".

print("Prvi redak")

>>>Definiraj x=2 te ispiši tekst "x je jednak" te vrijednost od x.

x=2
print("x je jednak", x)

>>>Definiraj x=2 i y=5 te ispiši rezultat logičke provjere je li x veći ili jednak od y.

x=2
y=5
print("x je veći ili jednak y", x >= y)

>>>Definiraj x=2, y=5, z=7. Ispiši rezultat aritmetičke operacije y^x * logz.

import numpy as np

x=2
y=5
z=7

rezultat=np.power(y,x)*np.log10(z)
print(rezultat) 

#log računa ln, a log10 računa log

#Zadatak 3.
>>>Kreiraj if naredbu koja za zadani broj x ispisuje "Broj nije izdvojenica", ako se nalazi između -3 i 3. U protivnom if naredba ispisuje "Broj je izdvojenica". (Uputa: Na početku zadajte da je 
 te provjerite točnost if naredbe. Mijenjajte vrijednost x kako bi se uvjerili funkcionira li sve točno.

x=2

if x > -3 and x < 3:
    print ("Broj nije izdvojenica")
else:
    print ("Broj je izdvojenica")

>>>Kreiraj for naredbu koja iterira po elementima liste [11,13,17,19] te ispisuje elemente liste.

x=[11,13,17,19]

for i in x:
    print(i)

>>>Kreiraj for naredbu koja iterira po elementima liste [11,13,17,19] te ispisuje True ako se broj čita isto s lijeva i s desna.

brojevi = [11, 13, 17, 19]

for i in brojevi:
    str_i = str(i)
    if str_i == str_i[::-1]:
        print(True)
    else:
        print(False)

#Zadatak 4. Učitaj paket NumPy pod alisom np te riješi sljedeće zadatke:
>>>Definiraj matricu nula 4x7, oznaka: A.

import numpy as np

A=np.zeros((4,7))
print(A)

>>>Definiraj matricu jedinica 4x7, oznaka: B.

B=np.ones((4,7))
print(B)

>>>Definiraj matricu slučajnih brojeva iz jednolike distribucije s modalitetima 0,1,2,3,4, dimenzija 4x4, oznaka: C. 
Izračunaj C^2 i CxC. Razlikuju li se rezultati? Objasni.

C=np.random.randint(0,5,(4,4))

print(C)

#kvadriranje
C_kvadrat=np.power(C,2)
print(C_kvadrat)

#množenje
C = np.array([[2, 0, 4, 1],
              [4, 1, 1, 3],
              [4, 1, 3, 1],
              [2, 2, 3, 2]])

rezultat_mnozenja = np.dot(C, C)

print(rezultat_mnozenja)

Rezultati se razlikuju jer kod kvadriranja rezultat je matrica u kojoj je svaki element kvadriran, a kod množenja se vrši matrično množenje.

>>>Definiraj matricu D proizvoljnih dimenzija te ispiši njen broj stupaca i redaka.

D=np.array([[11, 13, 17, 19], [10, 12, 16, 18]])
print(D)

print("oblik matrice", np.shape(D))

>>> Definiraj matricu E dimenzija 20x1 koja sadrži slučajne brojeve iz uniformne distribucije s modalitetima u [0,1].
Ispiši prvi element, sedmi element, te predzadnji element.

E=np.random.random((20,1))
print(E)

print("1.element", E[0,0])
print("7.element", E[6,0])
print("predzadnji element", E[18,0])

>>>Definiraj matricu F proizvoljnih dimenzija (broj redaka i stupaca je veći od 5) te ispiši parne retke.

F=np.random.random((6,6))
print(F)

print("\n parni retci", F[1:6:2,:])

>>>Definiraj matricu G proizvoljnih dimenzija (broj redaka i stupaca je veći od 5) te ispiši maksimalni element matrice,
poziciju maksimalnog elementa te maksimum po stupcima.

G=np.random.normal(0,1,(7,7))
print(G)

#maksimalni element
def pronadi_maksimalni_element(G):
    # Koristi list comprehension za dobivanje svih elemenata iz matrice
    svi_elementi = [element for red in G for element in red]
    
    # Pronađi maksimalni element u listi svih elemenata
    maksimalni_element = max(svi_elementi)
    
    return maksimalni_element

rezultat = pronadi_maksimalni_element(G)
print("Maksimalni element matrice je:", rezultat)

maksimalni_element = G[0][0]
indeksi_maksimalnog_elementa = (0, 0)

#pozicija
for i, red in enumerate(G):
    # Iterirajte kroz elemente u svakom redu
    for j, element in enumerate(red):
        # Ako je trenutni element veći od trenutnog maksimalnog, ažurirajte maksimalni element i indekse
        if element > maksimalni_element:
            maksimalni_element = element
            indeksi_maksimalnog_elementa = (i, j)

# Ispis pozicije maksimalnog elementa nakon što je petlja završena
print("Pozicija maksimalnog elementa u matrici je:", indeksi_maksimalnog_elementa)

#maksimum po stupcima
def maksimum_po_stupcima(G):
    # Pretvori matricu u NumPy array
    np_matrica = np.array(G)
    
    # Koristi funkciju np.max s parametrom axis=0 za pronalaženje maksimuma po stupcima
    maksimumi_po_stupcima = np.max(np_matrica, axis=0)
    
    return maksimumi_po_stupcima


rezultat = maksimum_po_stupcima(G)
print("Maksimumi po stupcima su:", rezultat)

#Zadatak 5. Učitaj podatke iz csv GTzadaci.csv. U dokumentu se nalaze tri Google Trends niza koji prikazuju popularnost pojmova: financije, inflacija i recesija te Indeks pouzdanja potrošača (Consumer Confidence Index, CCI).
Google Trends podaci se interpretiraju kao popularnost pretraživanja pojma, dok CCI odražava pouzdanje. 
Svi podaci su izračunani za Hrvatsku za period 01/2020 - 11/2023. Riješi sljedeće zadatke:
>>>Objasni značenje index_col=0 i parse_dates=True.

#index.col=0 znači da će se prvi stupac podataka iz CSV-a koristiti kao indeks data framea
#parse_dates=True naglašava Pythonu da se radi o vremenskom nizu podataka

>>>Objasni elemente objekta data: columns, index i values.

#columns je oznaka stupca, index je oznaka retka, a values se odnosi na podatke koji su pohranjeni u data frameu

>>> Ispiši prvi redak i prvi stupac. Objasni što prikazuju ispisani podaci.

print(data.iloc[0,:])
print(data.iloc[:,0])

#u ispisu prvog retka vidljivi su nazivi stupaca, tj. njihove oznake
#u ispisu prvog stupca vidljivi su podaci o popularnosti pojma financije

>>>Pomoću for petlje izračunaj prvu diferenciju za niz inflacija i prikaži ga grafički.

delta = pd.DataFrame(np.nan, index=data.index, columns=data.columns)
#print(delta)
#nan je funkcija "nepostojeća vrijednost"

[m,n]=data.shape #m-broj redaka, n-broj stupaca

# 2. stupac
for i in range(1,m): #krećemo od drugog retka jer nemamo vrijednosti prije 1.razdoblja
    delta.iloc[i,1]=data.iloc[i,1]-data.iloc[(i-1),1] #punimo 2. stupac, trebaju nam diferencije znači vrijednost danas-vrijednost jučer

print(delta.iloc[:,1]) #ili print(delta.iloc[:,:]) ako želimo cijelu tablicu

#grafički prikaz
import matplotlib.pyplot as plt

plt.plot(delta.loc["2010-01-01":,"inflacija"], label=delta.columns[1])

plt.xlabel("Mjeseci")
plt.ylabel("Prva diferencija")
plt.title("Google Trends podaci")
#plt.yticks([0,25,50,75,100])
#plt.grid(True)
plt.legend(loc='upper left', fontsize='small')

plt.show()
plt.close()

>>> Grafički prikaži sva tri GT indikatora, što zaključuješ?

plt.plot(data, label=data.columns)

plt.xlabel("Mjeseci")
plt.ylabel("Indeks")
plt.title("Google Trends podaci")
#plt.yticks([0,25,50,75,100])
#plt.grid(True)
plt.legend(loc='upper left', fontsize='small')

plt.show()
plt.close()

#Iz grafičkog prikaza možemo zaključiti da popularnost pretraživanja "financija" konstantno varira, stacionarnost niza?
#Za pojam inflacije vidimo značajan rast popularnosti poslije 2020. - pandemija.
#Za pojam recesije također vidimo manji porast 2020.
#Pouzdanje potrošača varira, raste polako nakon globalne krize 2008., a zatim 2020. opet doživljava pad s obzirom na pandemiju.

>>>Pomoću scatter plota prikaži GT indikatore recesija i inflacija, što zaključuješ?

plt.style.use("classic")

plt.scatter(data["recesija"],data["inflacija"])

plt.title("Dijagram rasipanja")

plt.show()
plt.close()

#Iz dijagrama rasipanja možemo uočiti da ne postoji veza između popularnosti pojmova recesija i inflacija ni u kojem smjeru. 
#Podaci su grupirani na početku, ali nema očite veze između njih, dok s vremenskom odmakom ikakva povezanost iščezava.

>>>Prikaži distribuciju GT indikatora za recesiju, što zaključuješ?

plt.style.use("classic")

plt.hist(data["recesija"],bins=5,range=[0,100])

plt.xlabel("Mjeseci")
plt.ylabel("Indeks")
plt.title("Distribucija popularnosti pojma recesija")

plt.show()
plt.close()

#Iz histograma možemo uočiti da je popularnost pretraživanja pojma recesija najveća u razdoblju od 2010. do 2012., a nakon toga znatno pada.

>>>Definiraj novi indikator kao omjer GT indikatora recesija i inflacija. Prikaži ga grafički i izračunaj deskriptivnu analizu. Što zaključuješ?

#novi inidikator
data["ratio"]=data["recesija"]/data["inflacija"]*100
print(data)

#grafički prikaz
plt.plot(data.loc[:,"ratio"], label=data.columns[4])

plt.xlabel("Mjeseci")
plt.ylabel("Indeks")
plt.title("Google Trends podaci")
#plt.yticks([0,25,50,75,100])
#plt.grid(True)
plt.legend(loc='upper left', fontsize='small')

plt.show()
plt.close()

#deskriptivna
ratio=data["recesija"]/data["inflacija"]*100
descriptives = ratio.describe()

print(descriptives)

#Prosječna vrijednost omjera iznosi 115,47 - recesija je u prosjeku popularnija od inflacije kao pojam pretraživanja.
#Standardna devijacija iznosi 517,46 - velika varijabilnost 
#Prvih 50% podataka o iznosu omjera ima vrijednost 38,09 i manje, dok ostalih 50% podataka ima vrijednost 38,09 i više. - inflacija bi onda bila popularna
#možemo pretpostaviti da imamo outliere koji jako utječu na prosjek i iskrivljavaju sliku o popularnosti pretraživanja.



















