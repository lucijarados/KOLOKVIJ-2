#Zadatak 2.
>>>Ispiši tekst "Prvi redak".

print("Prvi redak")

>>>Definiraj x=2 te ispiši tekst "x je jednak" te vrijednost od x.

x=2
print("x je jednak", x)

>>>Definiraj x=2 i y=5 te ispiši rezultat logičke provjere je li x veći ili jednak od y.

x=2
y=5
print("x je veći ili jednak y", x >= y)

>>>Definiraj x=2, y=5, z=7. Ispiši rezultat aritmetičke operacije y^x * logz.

import numpy as np

x=2
y=5
z=7

rezultat=np.power(y,x)*np.log10(z)
print(rezultat) 

#log računa ln, a log10 računa log

#Zadatak 3.
>>>Kreiraj if naredbu koja za zadani broj x ispisuje "Broj nije izdvojenica", ako se nalazi između -3 i 3. U protivnom if naredba ispisuje "Broj je izdvojenica". (Uputa: Na početku zadajte da je 
 te provjerite točnost if naredbe. Mijenjajte vrijednost x kako bi se uvjerili funkcionira li sve točno.

x=2

if x > -3 and x < 3:
    print ("Broj nije izdvojenica")
else:
    print ("Broj je izdvojenica")

>>>Kreiraj for naredbu koja iterira po elementima liste [11,13,17,19] te ispisuje elemente liste.

x=[11,13,17,19]

for i in x:
    print(i)

>>>Kreiraj for naredbu koja iterira po elementima liste [11,13,17,19] te ispisuje True ako se broj čita isto s lijeva i s desna.

brojevi = [11, 13, 17, 19]

for i in brojevi:
    str_i = str(i)
    if str_i == str_i[::-1]:
        print(True)
    else:
        print(False)

#Zadatak 4. Učitaj paket NumPy pod alisom np te riješi sljedeće zadatke:
>>>Definiraj matricu nula 4x7, oznaka: A.

import numpy as np

A=np.zeros((4,7))
print(A)

>>>Definiraj matricu jedinica 4x7, oznaka: B.

B=np.ones((4,7))
print(B)

>>>Definiraj matricu slučajnih brojeva iz jednolike distribucije s modalitetima 0,1,2,3,4, dimenzija 4x4, oznaka: C. 
Izračunaj C^2 i CxC. Razlikuju li se rezultati? Objasni.

C=np.random.randint(0,5,(4,4))

print(C)

#kvadriranje
C_kvadrat=np.power(C,2)
print(C_kvadrat)

#množenje
C = np.array([[2, 0, 4, 1],
              [4, 1, 1, 3],
              [4, 1, 3, 1],
              [2, 2, 3, 2]])

rezultat_mnozenja = np.dot(C, C)

print(rezultat_mnozenja)

Rezultati se razlikuju jer kod kvadriranja rezultat je matrica u kojoj je svaki element kvadriran, a kod množenja se vrši matrično množenje.

>>>Definiraj matricu D proizvoljnih dimenzija te ispiši njen broj stupaca i redaka.

D=np.array([[11, 13, 17, 19], [10, 12, 16, 18]])
print(D)

print("oblik matrice", np.shape(D))

>>> Definiraj matricu E dimenzija 20x1 koja sadrži slučajne brojeve iz uniformne distribucije s modalitetima u [0,1].
Ispiši prvi element, sedmi element, te predzadnji element.

E=np.random.random((20,1))
print(E)

print("1.element", E[0,0])
print("7.element", E[6,0])
print("predzadnji element", E[18,0])

>>>Definiraj matricu F proizvoljnih dimenzija (broj redaka i stupaca je veći od 5) te ispiši parne retke.

F=np.random.random((6,6))
print(F)

print("\n parni retci", F[1:6:2,:])

>>>Definiraj matricu G proizvoljnih dimenzija (broj redaka i stupaca je veći od 5) te ispiši maksimalni element matrice,
poziciju maksimalnog elementa te maksimum po stupcima.

G=np.random.normal(0,1,(7,7))
print(G)

#maksimalni element
def pronadi_maksimalni_element(G):
    # Koristi list comprehension za dobivanje svih elemenata iz matrice
    svi_elementi = [element for red in G for element in red]
    
    # Pronađi maksimalni element u listi svih elemenata
    maksimalni_element = max(svi_elementi)
    
    return maksimalni_element

rezultat = pronadi_maksimalni_element(G)
print("Maksimalni element matrice je:", rezultat)

maksimalni_element = G[0][0]
indeksi_maksimalnog_elementa = (0, 0)

#pozicija
for i, red in enumerate(G):
    # Iterirajte kroz elemente u svakom redu
    for j, element in enumerate(red):
        # Ako je trenutni element veći od trenutnog maksimalnog, ažurirajte maksimalni element i indekse
        if element > maksimalni_element:
            maksimalni_element = element
            indeksi_maksimalnog_elementa = (i, j)

# Ispis pozicije maksimalnog elementa nakon što je petlja završena
print("Pozicija maksimalnog elementa u matrici je:", indeksi_maksimalnog_elementa)

#maksimum po stupcima
def maksimum_po_stupcima(G):
    # Pretvori matricu u NumPy array
    np_matrica = np.array(G)
    
    # Koristi funkciju np.max s parametrom axis=0 za pronalaženje maksimuma po stupcima
    maksimumi_po_stupcima = np.max(np_matrica, axis=0)
    
    return maksimumi_po_stupcima


rezultat = maksimum_po_stupcima(G)
print("Maksimumi po stupcima su:", rezultat)

#Zadatak 5. Učitaj podatke iz csv GTzadaci.csv. U dokumentu se nalaze tri Google Trends niza koji prikazuju popularnost pojmova: financije, inflacija i recesija te Indeks pouzdanja potrošača (Consumer Confidence Index, CCI).
Google Trends podaci se interpretiraju kao popularnost pretraživanja pojma, dok CCI odražava pouzdanje. 
Svi podaci su izračunani za Hrvatsku za period 01/2020 - 11/2023. Riješi sljedeće zadatke:
>>>Objasni značenje index_col=0 i parse_dates=True.

#index.col=0 znači da će se prvi stupac podataka iz CSV-a koristiti kao indeks data framea
#parse_dates=True naglašava Pythonu da se radi o vremenskom nizu podataka

>>>Objasni elemente objekta data: columns, index i values.

#columns je oznaka stupca, index je oznaka retka, a values se odnosi na podatke koji su pohranjeni u data frameu

>>> Ispiši prvi redak i prvi stupac. Objasni što prikazuju ispisani podaci.

print(data.iloc[0,:])
print(data.iloc[:,0])

#u ispisu prvog retka vidljivi su nazivi stupaca, tj. njihove oznake
#u ispisu prvog stupca vidljivi su podaci o popularnosti pojma financije

>>>Pomoću for petlje izračunaj prvu diferenciju za niz inflacija i prikaži ga grafički.

delta = pd.DataFrame(np.nan, index=data.index, columns=data.columns)
#print(delta)
#nan je funkcija "nepostojeća vrijednost"

[m,n]=data.shape #m-broj redaka, n-broj stupaca

# 2. stupac
for i in range(1,m): #krećemo od drugog retka jer nemamo vrijednosti prije 1.razdoblja
    delta.iloc[i,1]=data.iloc[i,1]-data.iloc[(i-1),1] #punimo 2. stupac, trebaju nam diferencije znači vrijednost danas-vrijednost jučer

print(delta.iloc[:,1]) #ili print(delta.iloc[:,:]) ako želimo cijelu tablicu

#grafički prikaz
import matplotlib.pyplot as plt

plt.plot(delta.loc["2010-01-01":,"inflacija"], label=delta.columns[1])

plt.xlabel("Mjeseci")
plt.ylabel("Prva diferencija")
plt.title("Google Trends podaci")
#plt.yticks([0,25,50,75,100])
#plt.grid(True)
plt.legend(loc='upper left', fontsize='small')

plt.show()
plt.close()

>>> Grafički prikaži sva tri GT indikatora, što zaključuješ?

plt.plot(data, label=data.columns)

plt.xlabel("Mjeseci")
plt.ylabel("Indeks")
plt.title("Google Trends podaci")
#plt.yticks([0,25,50,75,100])
#plt.grid(True)
plt.legend(loc='upper left', fontsize='small')

plt.show()
plt.close()

#Iz grafičkog prikaza možemo zaključiti da popularnost pretraživanja "financija" konstantno varira, stacionarnost niza?
#Za pojam inflacije vidimo značajan rast popularnosti poslije 2020. - pandemija.
#Za pojam recesije također vidimo manji porast 2020.
#Pouzdanje potrošača varira, raste polako nakon globalne krize 2008., a zatim 2020. opet doživljava pad s obzirom na pandemiju.

>>>Pomoću scatter plota prikaži GT indikatore recesija i inflacija, što zaključuješ?

plt.style.use("classic")

plt.scatter(data["recesija"],data["inflacija"])

plt.title("Dijagram rasipanja")

plt.show()
plt.close()

#Iz dijagrama rasipanja možemo uočiti da ne postoji veza između popularnosti pojmova recesija i inflacija ni u kojem smjeru. 
#Podaci su grupirani na početku, ali nema očite veze između njih, dok s vremenskom odmakom ikakva povezanost iščezava.

>>>Prikaži distribuciju GT indikatora za recesiju, što zaključuješ?

plt.style.use("classic")

plt.hist(data["recesija"],bins=5,range=[0,100])

plt.xlabel("Mjeseci")
plt.ylabel("Indeks")
plt.title("Distribucija popularnosti pojma recesija")

plt.show()
plt.close()

#Iz histograma možemo uočiti da je popularnost pretraživanja pojma recesija najveća u razdoblju od 2010. do 2012., a nakon toga znatno pada.

>>>Definiraj novi indikator kao omjer GT indikatora recesija i inflacija. Prikaži ga grafički i izračunaj deskriptivnu analizu. Što zaključuješ?

#novi inidikator
data["ratio"]=data["recesija"]/data["inflacija"]*100
print(data)

#grafički prikaz
plt.plot(data.loc[:,"ratio"], label=data.columns[4])

plt.xlabel("Mjeseci")
plt.ylabel("Indeks")
plt.title("Google Trends podaci")
#plt.yticks([0,25,50,75,100])
#plt.grid(True)
plt.legend(loc='upper left', fontsize='small')

plt.show()
plt.close()

#deskriptivna
ratio=data["recesija"]/data["inflacija"]*100
descriptives = ratio.describe()

print(descriptives)

#Prosječna vrijednost omjera iznosi 115,47 - recesija je u prosjeku popularnija od inflacije kao pojam pretraživanja.
#Standardna devijacija iznosi 517,46 - velika varijabilnost 
#Prvih 50% podataka o iznosu omjera ima vrijednost 38,09 i manje, dok ostalih 50% podataka ima vrijednost 38,09 i više. - inflacija bi onda bila popularna
#možemo pretpostaviti da imamo outliere koji jako utječu na prosjek i iskrivljavaju sliku o popularnosti pretraživanja.


#Zadatak 6. Učitaj podatke iz csv GTzadaci.csv. Riješi sljedeće zadatke:
>>>Izračunajte stopu promjene za GT indikatore po formuli gt=lnGTt-lnGTt-12*100. (Uputa: prethodno korigiraj 0 u 1 zbog logaritma.)

# Change elements equal to 0 to 1
data[data.values == 0] = 1

# Calculate natural logarithm for all columns except the last one
log_data = np.log(data.iloc[:, :-1])

# Create 'delta_log' DataFrame filled with NaN values for all columns except the last one
delta_log = pd.DataFrame(np.nan, index=log_data.index, columns=log_data.columns)

[m, n] = log_data.shape  # m - number of rows, n - number of columns

# Calculate rate of change for natural logarithm for all columns except the last one between time t and time t-12
for j in range(n):
    for i in range(12, m):
        delta_log.iloc[i, j] = log_data.iloc[i, j] - log_data.iloc[i - 12, j]

# Print the result
print("Rate of change for natural logarithm for all columns except the last one between time t and time t-12:")
print(delta_log.iloc[12:, :])  # Skip the first 12 rows with NaN values

>>>Izračunajte diferenciju promjene za CCI indikator po formuli deltaCCIt=CCIt-CCIt-12.

delta_last_column = pd.DataFrame(np.nan, index=data.index, columns=[data.columns[-1]])

[m, n] = data.shape  # m - number of rows, n - number of columns

# Calculate differences for the last column between time t and time t-12
delta_last_column.iloc[12:, 0] = data.iloc[12:, -1].values - data.iloc[:-12, -1].values

# Print the result
print("Differences for the last column between time t and time t-12:")
delta_last_column.rename(columns={'CCI': 'deltaCCI'}, inplace=True)
print(delta_last_column)

#dodat ćemo deltaCCI postojećem dataframeu "data"
data = pd.concat([data, delta_last_column], axis=1)
print(data)

>>>Procijeni regresijski model i napiši regresijsku jednadžbu. deltaCCIt=ß0 + ß1gt,recesija + et

#slope je ß1
#intercept je ß0

import numpy as np #izračuni
import pandas as pd #učitavanje data framea
import matplotlib.pyplot as plt #vizualizacija
from sklearn.linear_model import LinearRegression #procjene modela, paket: scikit-learn


# Da bi mogli pozvati linearnu regresiju, treba imati numpy objekte

X = data.iloc[:, 2].values.reshape(-1, 1)  
Y = data.iloc[:, 4].values.reshape(-1, 1) 
# -1 znači da python sam prepozna koliko ima redaka, 1 znači da objekt treba imati jedan stupac

#stvara objekt za linearnu regresiju
linear_regressor = LinearRegression()  

linear_regressor.fit(X, Y)  # perform linear regression
Y_pred = linear_regressor.predict(X)  # make predictions

from sklearn import metrics
  
# printing values 
print('Slope:' ,linear_regressor.coef_) 
print('Intercept:', linear_regressor.intercept_) 

deltaCCIt=2,75 - 0,14gt,recesija

#fali greška relacije

>>> Izračunaj regresijske vrijednosti te ih ucrtaj na dijagram rasipanja. Što zaključuješ?

plt.scatter(X, Y)
plt.show()

#dijagram rasipanja?? 

>>>Ocijeni fit prethodnog modela tako da koristiš barem dva različita indikatora. Što zaključuješ?

rmse = np.sqrt(mse) 
r2 = metrics.r2_score(Y, Y_pred) 
print("RMSE",rmse)
print("R2", r2)

RMSE 9.41015937928068
R2 0.030726273351731392

#Budući da je koeficijent determinacije samo 3% zaključujemo da je ovaj model iznimno loš za prikazivanje podataka.

>>>Procijeni model pomoću statsmodels.api libraryija. Komentiraj rezultate testa značajnosti nezavisnih varijabli.

import statsmodels.api as sm

X0=sm.add_constant(X)
reg_a=sm.OLS(Y,X0).fit()

reg_a.summary()


#p-vrijednost=0,023
#ako je alfa=5%, donosimo p-vrijednost je manja od alfa, odbacujemo nultu hipotezu i zaključujemo da je varijabla gt,recesija statistički značajna u modelu

#Zadatak 7.  Koristeći podatke definirane u Zadatku 6 izračunaj sljedeće zadatke:
>>> Procijeni linerni regresijski model kao prvi samo su nam svi gt indikatori nezavisne varijable te napiši procijenjenu jednadžbu.


import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression

# Assuming 'data' is your DataFrame
X = data[['financije', 'recesija', 'inflacija']]  # Assuming 'X1', 'X2', 'X3' are your column names
Y = data['deltaCCI']

# Create a Linear Regression model
linear_regressor = LinearRegression()

# Fit the model
linear_regressor.fit(X, Y)

# Print the coefficients and intercept
print('Coefficients:', linear_regressor.coef_)
print('Intercept:', linear_regressor.intercept_)

# Predict using the trained model
Y_pred = linear_regressor.predict(X)

Coefficients: [ 0.07336261 -0.14353814 -0.1335101 ]
Intercept: 0.8801216152762595

deltaCCIt=0,88 + 0,07gt,financije - 0,14gt,recesija - 0,13gt,inflacija

>>>Procijeni model pomoću statsmodels.api libraryija. Komentiraj rezultate testa značajnosti nezavisnih varijabli.

import statsmodels.api as sm

# Assuming 'data' is your DataFrame with multiple independent variables (X1, X2, X3, ...)
# and a dependent variable 'Y'
X = data[['financije', 'recesija', 'inflacija']]  # Include all independent variables
Y = data['deltaCCI']

# Add a constant term to the independent variables
X0 = sm.add_constant(X)

# Fit the OLS regression model
reg_a = sm.OLS(Y, X0).fit()

# Display the summary tistics
print(reg_a.summary())

#Usporedbom p-vrijednosti i alfa na 5%, recesija i inflacija su statistički značajne u modelu, dok financije nisu. 

>>> Ocijeni fit prethodnog modela tako da koristiš barem dva različita indikatora. Što zaključuješ?

#ne vrtimo dodatni kod jer u prethodnom imamo sve izračunato

====
Dep. Variable:               deltaCCI   R-squared:                       0.116
Model:                            OLS   Adj. R-squared:                  0.099
Method:                 Least Squares   F-statistic:                     7.106
Date:                Sat, 13 Jan 2024   Prob (F-statistic):           0.000162
Time:                        12:32:00   Log-Likelihood:                -578.29
No. Observations:                 167   AIC:                             1165.
Df Residuals:                     163   BIC:                             1177.


#koeficijent determinacije samo 11,6%, AIC i BIC relativno veliki, znači da je model loš.

>>> Usporedi fit prethodnog modela i modela iz Zadatka 5 tako da koristiš barem dva različita indikatora. Što zaključuješ?

#ispis za model iz prošlog zadatka
R-squared:	0.031
Adj. R-squared:	0.025
AIC:	1176.
BIC:	1182.

#Koeficijent determinacije nije baš mjerodavan za usporedbu jer smo u ovaj model dodali više varijabli pa ćemo gledati korigirani.
#Za 1. model je korigirani R2=0,025, a za 2. model=0,099, iz čega zaključujemo da je 2. model bolji jer je korigirani R2 veći.
#ako uspoređujemo informacijske kriterije, AIC za 1. model=1176, a za 2. model=1165 -> 2. model je bolji
#BIC za 1. model=1182, a za 2. model=1177 -> 2. model je bolji
#možemo pogledati još i RMSE, za 1. model RMSE 9.41015937928068, a za 2. model RMSE 7.720564273447207 -> 2. model je bolji jer je RMSE manji


#da izračunamo RMSE za 2. model (ubacili smo u dio koda gdje smo procijenili regresiju)
RMSE=np.sqrt(np.mean(((Y-Y_pred)**2))) #prosječno kvadratno odstupanje 
print(RMSE)
















